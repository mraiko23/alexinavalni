<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üå± Plants vs Brainrots Stock Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 8px 32px rgba(138, 43, 226, 0.2);
        }

        h1 {
            font-size: 2.5em;
            color: #fff;
            text-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
            margin-bottom: 10px;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .status-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-item.active {
            border-color: #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .stock-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .stock-section {
            margin-bottom: 25px;
        }

        .stock-section:last-child {
            margin-bottom: 0;
        }

        .stock-title {
            font-size: 1.5em;
            color: #fff;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(138, 43, 226, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stock-title .emoji {
            font-size: 1.2em;
        }

        .stock-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
        }

        .stock-item {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .stock-item:hover {
            transform: translateY(-3px);
            border-color: rgba(138, 43, 226, 0.8);
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.4);
        }

        .stock-item.tracked {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .stock-item.tracked::after {
            content: '‚≠ê';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 1.2em;
        }

        .item-name {
            font-weight: bold;
            color: #fff;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .item-rarity {
            font-size: 0.8em;
            margin-bottom: 4px;
            padding: 2px 6px;
            border-radius: 10px;
            display: inline-block;
        }

        .rarity-Common { background: #b0b0b0; color: #333; }
        .rarity-Rare { background: #4169e1; color: #fff; }
        .rarity-Epic { background: #9370db; color: #fff; }
        .rarity-Mythic { background: #ff1493; color: #fff; }
        .rarity-Divine { background: #ffd700; color: #333; }
        .rarity-Secret { background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3); color: #fff; }

        .item-quantity {
            color: #4caf50;
            font-size: 1.2em;
            font-weight: bold;
        }

        .item-price {
            color: #ffd700;
            font-size: 0.9em;
            margin-top: 4px;
        }

        .sources-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .sources-title {
            font-size: 1.5em;
            color: #fff;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(138, 43, 226, 0.5);
        }

        .source-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 10px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .source-item.healthy {
            border-color: #4caf50;
        }

        .source-item.broken {
            border-color: #f44336;
            opacity: 0.6;
        }

        .source-item.partial {
            border-color: #ff9800;
        }

        .source-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .source-name {
            font-weight: bold;
            font-size: 0.9em;
            color: #fff;
        }

        .source-status {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
        }

        .source-status.healthy {
            background: #4caf50;
            color: #fff;
        }

        .source-status.broken {
            background: #f44336;
            color: #fff;
        }

        .source-status.partial {
            background: #ff9800;
            color: #fff;
        }

        .source-info {
            font-size: 0.8em;
            color: #aaa;
            margin-top: 5px;
        }

        .debug-info {
            font-size: 0.7em;
            color: #666;
            margin-top: 3px;
            font-family: monospace;
        }

        .tracking-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .tracking-title {
            font-size: 1.5em;
            color: #fff;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(138, 43, 226, 0.5);
        }

        .tracked-items {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tracked-item {
            background: rgba(255, 215, 0, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid #ffd700;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .tracked-item button {
            background: rgba(244, 67, 54, 0.8);
            border: none;
            color: #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-weight: bold;
            line-height: 1;
            transition: all 0.3s ease;
        }

        .tracked-item button:hover {
            background: #f44336;
            transform: scale(1.1);
        }

        .notifications-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .notifications-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .notifications-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .empty-state {
            text-align: center;
            color: #888;
            padding: 20px;
            font-style: italic;
        }

        .last-update {
            font-size: 0.85em;
            color: #888;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
            color: #888;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2em;
            }

            .stock-items {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5em;
            }

            .stock-items {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }

            .status-bar {
                flex-direction: column;
                gap: 10px;
            }
        }

        .debug-log {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.8em;
        }

        .debug-log-entry {
            margin-bottom: 5px;
            padding: 3px;
        }

        .debug-log-entry.error {
            color: #ff6b6b;
        }

        .debug-log-entry.success {
            color: #51cf66;
        }

        .debug-log-entry.info {
            color: #74c0fc;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üå± Plants vs Brainrots Stock Tracker üßü</h1>
            <div class="status-bar">
                <div class="status-item active" id="statusIndicator">
                    <span id="statusText">‚ö° –ó–∞–≥—Ä—É–∑–∫–∞...</span>
                </div>
                <div class="status-item">
                    <span id="lastUpdateTime">–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: --:--</span>
                </div>
                <div class="status-item">
                    <span id="healthySources">–ò—Å—Ç–æ—á–Ω–∏–∫–æ–≤: 0/4</span>
                </div>
            </div>
        </header>

        <div class="main-content">
            <div class="stock-panel">
                <div class="stock-section">
                    <div class="stock-title">
                        <span>‚öôÔ∏è Gear Stock</span>
                        <span class="last-update" id="gearUpdate">--:--</span>
                    </div>
                    <div class="stock-items" id="gearStockItems">
                        <div class="loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                    </div>
                </div>

                <div class="stock-section">
                    <div class="stock-title">
                        <span>üå± Seed Stock</span>
                        <span class="last-update" id="seedUpdate">--:--</span>
                    </div>
                    <div class="stock-items" id="seedStockItems">
                        <div class="loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                    </div>
                </div>
            </div>

            <div>
                <div class="sources-panel">
                    <div class="sources-title">üì° –ò—Å—Ç–æ—á–Ω–∏–∫–∏ –¥–∞–Ω–Ω—ã—Ö</div>
                    <div id="sourcesList">
                        <div class="loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                    </div>
                </div>

                <div class="tracking-panel" style="margin-top: 20px;">
                    <div class="tracking-title">‚≠ê –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã</div>
                    <button class="notifications-btn" id="notificationsBtn" onclick="requestNotificationPermission()">
                        üîî –í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
                    </button>
                    <div style="margin-top: 15px; display: flex; gap: 10px;">
                        <input type="text" id="manualTrackInput" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–µ–¥–º–µ—Ç–∞..." 
                               style="flex: 1; padding: 10px; border-radius: 8px; border: 2px solid rgba(138, 43, 226, 0.3); background: rgba(255, 255, 255, 0.05); color: #fff; font-size: 0.9em;"
                               onkeypress="if(event.key === 'Enter') addManualTracking()">
                        <button onclick="addManualTracking()" 
                                style="padding: 10px 20px; border-radius: 8px; border: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; font-weight: bold; cursor: pointer; transition: all 0.3s ease;">
                            ‚ûï –î–æ–±–∞–≤–∏—Ç—å
                        </button>
                    </div>
                    <div class="tracked-items" id="trackedItems" style="margin-top: 15px;">
                        <div class="empty-state">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤—ã—à–µ</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Debug Log -->
        <div class="debug-log" id="debugLog">
            <div class="debug-log-entry info">üìä Debug Log (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 50 –∑–∞–ø–∏—Å–µ–π)</div>
        </div>
    </div>

    <script>
        // Configuration
        const CORS_PROXY = 'https://corsproxy.io/?'; // CORS proxy –¥–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫
        
        const SOURCES = [
            { id: 1, url: 'https://api.plantvsbrainrots.org/api/stock/latest', type: 'api', name: 'API Source 1', useCorsProxy: false },
            { id: 2, url: 'https://plants-vs-brainrots.com/api/stock/', type: 'api', name: 'API Source 2', useCorsProxy: true },
            { id: 3, url: 'https://plantsvsbrainrotsstocktracker.com/api/stock?since=0', type: 'api', name: 'API Source 3', useCorsProxy: true },
            { id: 5, url: 'https://plantsvsbrainrotswikia.com/api/stock/current', type: 'api', name: 'API Source 5', useCorsProxy: true }
        ];

        const POLL_INTERVAL = 30000; // 30 seconds
        const REQUEST_TIMEOUT = 15000; // 15 seconds (—É–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è proxy)

        // State
        let currentStock = { gear: [], seed: [] };
        let sourcesData = new Map();
        let trackedItems = new Set(JSON.parse(localStorage.getItem('trackedItems') || '[]'));
        let notificationsEnabled = false;
        let lastStockHash = '';
        let debugLogs = [];

        // Debug logging
        function addDebugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('ru-RU');
            debugLogs.unshift({ timestamp, message, type });
            if (debugLogs.length > 50) debugLogs.pop();
            
            const logContainer = document.getElementById('debugLog');
            if (logContainer) {
                const logHTML = debugLogs.map(log => 
                    `<div class="debug-log-entry ${log.type}">[${log.timestamp}] ${log.message}</div>`
                ).join('');
                logContainer.innerHTML = `<div class="debug-log-entry info">üìä Debug Log (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 50 –∑–∞–ø–∏—Å–µ–π)</div>${logHTML}`;
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            addDebugLog('–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ', 'success');
            checkNotificationPermission();
            updateTrackedItemsUI();
            startPolling();
        });

        // Notification handling
        function checkNotificationPermission() {
            if ('Notification' in window) {
                if (Notification.permission === 'granted') {
                    notificationsEnabled = true;
                    document.getElementById('notificationsBtn').textContent = '‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã';
                    document.getElementById('notificationsBtn').disabled = true;
                    addDebugLog('–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω—ã', 'success');
                }
            } else {
                document.getElementById('notificationsBtn').textContent = '‚ùå –ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è';
                document.getElementById('notificationsBtn').disabled = true;
                addDebugLog('–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º', 'error');
            }
        }

        async function requestNotificationPermission() {
            if ('Notification' in window) {
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    notificationsEnabled = true;
                    document.getElementById('notificationsBtn').textContent = '‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã';
                    document.getElementById('notificationsBtn').disabled = true;
                    new Notification('üå± Plants vs Brainrots', {
                        body: '–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –≤–∫–ª—é—á–µ–Ω—ã! –í—ã –ø–æ–ª—É—á–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ–≥–¥–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–π –ø—Ä–µ–¥–º–µ—Ç –ø–æ—è–≤–∏—Ç—Å—è –≤ —Å—Ç–æ–∫–µ.',
                        icon: 'üå±'
                    });
                    addDebugLog('–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º', 'success');
                } else {
                    addDebugLog('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–∫–ª–æ–Ω–∏–ª —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è', 'error');
                    alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ä–∞–∑—Ä–µ—à–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –±—Ä–∞—É–∑–µ—Ä–∞');
                }
            }
        }

        function sendNotification(itemName) {
            if (notificationsEnabled && Notification.permission === 'granted') {
                new Notification('üå± –ü—Ä–µ–¥–º–µ—Ç –≤ —Å—Ç–æ–∫–µ!', {
                    body: `${itemName} —Ç–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–µ–Ω –≤ —Å—Ç–æ–∫–µ!`,
                    icon: '‚≠ê',
                    tag: itemName
                });
                addDebugLog(`–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ: ${itemName}`, 'success');
            }
        }

        // Polling
        function startPolling() {
            addDebugLog('–ó–∞–ø—É—Å–∫ –æ–ø—Ä–æ—Å–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤', 'info');
            pollAllSources();
            setInterval(pollAllSources, POLL_INTERVAL);
        }

        async function pollAllSources() {
            document.getElementById('statusText').textContent = '‚ö° –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ...';
            addDebugLog('üöÄ –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –æ–ø—Ä–æ—Å –≤—Å–µ—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤...', 'info');
            
            let sourcesReceived = 0;
            const totalSources = SOURCES.length;
            
            // Start all requests in parallel and handle each as it completes
            const promises = SOURCES.map(async (source) => {
                try {
                    const data = await fetchSourceData(source);
                    sourcesData.set(source.id, data);
                    sourcesReceived++;
                    
                    if (data.isValid) {
                        addDebugLog(`‚úÖ ${source.name}: –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (${data.gear.length} gear, ${data.seed.length} seed)`, 'success');
                    } else if (data.gear.length > 0 || data.seed.length > 0) {
                        addDebugLog(`‚ö†Ô∏è ${source.name}: —á–∞—Å—Ç–∏—á–Ω–æ (${data.gear.length} gear, ${data.seed.length} seed)`, 'info');
                    } else if (data.error) {
                        addDebugLog(`‚ùå ${source.name}: –æ—à–∏–±–∫–∞ - ${data.message}`, 'error');
                    } else {
                        addDebugLog(`‚ö†Ô∏è ${source.name}: –ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç`, 'error');
                    }
                    
                    // Recalculate consensus immediately after each source arrives
                    updateConsensusAndUI();
                    
                } catch (error) {
                    sourcesReceived++;
                    sourcesData.set(source.id, { 
                        gear: [],
                        seed: [],
                        error: true, 
                        message: error.toString(), 
                        source: source.id,
                        reportedAt: Date.now(),
                        isValid: false
                    });
                    addDebugLog(`‚ùå ${source.name}: –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ - ${error}`, 'error');
                    
                    // Still recalculate consensus
                    updateConsensusAndUI();
                }
            });

            // Wait for all sources to complete
            await Promise.allSettled(promises);
            
            addDebugLog(`üèÅ –í—Å–µ ${totalSources} –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã`, 'success');
            updateSourcesUI();
            updateStatusBar();
        }
        
        function updateConsensusAndUI() {
            const consensusStock = calculateConsensus();
            if (consensusStock) {
                // Check if consensus actually changed
                const newHash = hashStock(consensusStock);
                const oldHash = currentStock ? hashStock(currentStock) : '';
                
                if (newHash !== oldHash) {
                    checkForTrackedItems(consensusStock);
                    currentStock = consensusStock;
                    updateStockUI(consensusStock);
                    
                    addDebugLog(
                        `üîÑ –ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: ` +
                        `${consensusStock.gear.length} gear, ${consensusStock.seed.length} seed`,
                        'success'
                    );
                    
                    // Send aggregated data to our API endpoint
                    updateLocalAPI(consensusStock);
                }
            }
        }

        async function fetchSourceData(source, retryCount = 0) {
            const maxRetries = 2;
            const retryDelay = 2000;
            
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);

            try {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º CORS proxy –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                const fetchUrl = source.useCorsProxy ? CORS_PROXY + encodeURIComponent(source.url) : source.url;
                const proxyNote = source.useCorsProxy ? ' (via proxy)' : '';
                
                addDebugLog(`‚Üí –ó–∞–ø—Ä–æ—Å –∫ ${source.name}${proxyNote}${retryCount > 0 ? ` [–ø–æ–ø—ã—Ç–∫–∞ ${retryCount + 1}]` : ''}`, 'info');
                
                const response = await fetch(fetchUrl, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                clearTimeout(timeout);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –∏—Å—Ç–æ—á–Ω–∏–∫–∞
                if (source.type === 'html') {
                    const html = await response.text();
                    addDebugLog(`‚Üê ${source.name}: HTML –ø–æ–ª—É—á–µ–Ω (${html.length} –±–∞–π—Ç)`, 'success');
                    return parseHTMLResponse(html, source);
                } else {
                    const data = await response.json();
                    addDebugLog(`‚Üê ${source.name}: JSON –ø–æ–ª—É—á–µ–Ω (${JSON.stringify(data).length} –±–∞–π—Ç)`, 'success');
                    return parseAPIResponse(data, source);
                }
            } catch (error) {
                clearTimeout(timeout);
                const errorMsg = error.name === 'AbortError' ? 'Timeout' : (error.message || 'Network error');
                
                // Retry logic
                if (retryCount < maxRetries) {
                    addDebugLog(`‚ö†Ô∏è ${source.name}: ${errorMsg}, –ø–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ ${retryDelay/1000}—Å...`, 'error');
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    return fetchSourceData(source, retryCount + 1);
                }
                
                addDebugLog(`‚úó ${source.name}: ${errorMsg} (–≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∏—Å—á–µ—Ä–ø–∞–Ω—ã)`, 'error');
                throw errorMsg;
            }
        }

        function parseAPIResponse(data, source) {
            addDebugLog(`–ü–∞—Ä—Å–∏–Ω–≥ API –æ—Ç–≤–µ—Ç–∞ –æ—Ç ${source.name}`, 'info');
            
            let gearStock = [];
            let seedStock = [];
            let reportedAt = Date.now();

            try {
                // Format 1: {items: [...], updatedAt/reportedAt: timestamp}
                if (data.items && Array.isArray(data.items)) {
                    data.items.forEach(item => {
                        const normalizedItem = {
                            name: item.name || item.id || 'Unknown',
                            quantity: item.currentStock || item.qty || item.stock || item.quantity || item.amount || item.count || 1,
                            price: item.currentPrice || item.price || item.cost || 0,
                            category: item.category || ''
                        };

                        // Classify by category (plants = seeds)
                        if (item.category === 'seed' || item.category === 'seeds' || item.category === 'plant' || item.category === 'plants' || 
                            item.id?.includes('seed') || item.id?.includes('plant') || 
                            item.name?.toLowerCase().includes('seed') || item.name?.toLowerCase().includes('plant')) {
                            seedStock.push(normalizedItem);
                        } else if (item.category === 'gear' || item.category === 'gears' || 
                                   item.id?.includes('gear') || item.name?.toLowerCase().includes('gear')) {
                            gearStock.push(normalizedItem);
                        } else {
                            // Default: if has "seed" or "plant" in name -> seed, otherwise gear
                            if (item.name?.toLowerCase().includes('seed') || item.name?.toLowerCase().includes('plant')) {
                                seedStock.push(normalizedItem);
                            } else {
                                gearStock.push(normalizedItem);
                            }
                        }
                    });
                    
                    reportedAt = data.updatedAt || data.reportedAt || data.timestamp || Date.now();
                    addDebugLog(`API –ø–∞—Ä—Å–∏–Ω–≥: ${gearStock.length} gear, ${seedStock.length} seed`, 'success');
                }
                // Format 2: {stock: {gear: [...], seed: [...]}}
                else if (data.stock) {
                    gearStock = normalizeItems(data.stock.gear || data.stock.gearStock || data.stock.gears || []);
                    seedStock = normalizeItems(data.stock.seed || data.stock.seedStock || data.stock.seeds || []);
                    reportedAt = data.stock.reportedAt || data.stock.timestamp || data.reportedAt || Date.now();
                    addDebugLog(`API –ø–∞—Ä—Å–∏–Ω–≥ (—Ñ–æ—Ä–º–∞—Ç stock): ${gearStock.length} gear, ${seedStock.length} seed`, 'success');
                }
                // Format 3: Direct {gears: [...], seeds: [...]} or {gear: [...], seed: [...]}
                else if (data.gears || data.gear || data.seeds || data.seed) {
                    gearStock = normalizeItems(data.gears || data.gear || []);
                    seedStock = normalizeItems(data.seeds || data.seed || []);
                    
                    // Parse timestamp (handle ISO strings and millisecond timestamps)
                    const timeValue = data.reportedAt || data.effectiveTime || data.updatedAt || data.timestamp || Date.now();
                    reportedAt = typeof timeValue === 'string' ? new Date(timeValue).getTime() : timeValue;
                    
                    addDebugLog(`API –ø–∞—Ä—Å–∏–Ω–≥ (–ø—Ä—è–º–æ–π —Ñ–æ—Ä–º–∞—Ç): ${gearStock.length} gear, ${seedStock.length} seed`, 'success');
                }
                // Format 4: Array of items
                else if (Array.isArray(data)) {
                    data.forEach(item => {
                        const normalizedItem = normalizeItem(item);
                        if (item.type === 'gear' || item.category === 'gear') {
                            gearStock.push(normalizedItem);
                        } else {
                            seedStock.push(normalizedItem);
                        }
                    });
                    reportedAt = Date.now();
                    addDebugLog(`API –ø–∞—Ä—Å–∏–Ω–≥ (–º–∞—Å—Å–∏–≤): ${gearStock.length} gear, ${seedStock.length} seed`, 'success');
                }

                // Log detailed extraction info
                const gearNames = gearStock.map(g => `${g.name}(${g.quantity})`).join(', ');
                const seedNames = seedStock.map(s => `${s.name}(${s.quantity})`).join(', ');
                
                if (gearStock.length > 0) {
                    addDebugLog(`  ‚öôÔ∏è Gear: ${gearNames}`, 'info');
                }
                if (seedStock.length > 0) {
                    addDebugLog(`  üå± Seed: ${seedNames}`, 'info');
                }
                
                return {
                    gear: gearStock,
                    seed: seedStock,
                    reportedAt: reportedAt,
                    isValid: gearStock.length > 0 || seedStock.length > 0,  // Accept sources with EITHER gears OR seeds
                    source: source.id
                };
            } catch (err) {
                addDebugLog(`–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ API ${source.name}: ${err.message}`, 'error');
                return {
                    gear: [],
                    seed: [],
                    reportedAt: Date.now(),
                    isValid: false,
                    source: source.id,
                    error: true,
                    message: err.message
                };
            }
        }

        // Parse HTML response from HTML-based stock sources
        function parseHTMLResponse(html, source) {
            addDebugLog(`üîç –ù–∞—á–∞–ª–æ HTML –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è ${source.name}`, 'info');
            
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                const gearStock = [];
                const seedStock = [];
                
                // Strategy 1: Look for embedded JSON data in script tags (Next.js data)
                const scripts = doc.querySelectorAll('script[id="__NEXT_DATA__"], script[type="application/json"]');
                for (const script of scripts) {
                    try {
                        const jsonData = JSON.parse(script.textContent);
                        
                        // Check for direct stock data
                        if (jsonData.stock || jsonData.gear || jsonData.seed || jsonData.gears || jsonData.seeds) {
                            addDebugLog('‚úÖ –ù–∞–π–¥–µ–Ω—ã JSON –¥–∞–Ω–Ω—ã–µ –≤ HTML', 'success');
                            return parseAPIResponse(jsonData, source);
                        }
                        
                        // Check for Next.js pageProps
                        if (jsonData.props?.pageProps) {
                            const pageProps = jsonData.props.pageProps;
                            if (pageProps.stock || pageProps.gear || pageProps.seed || pageProps.gears || pageProps.seeds) {
                                addDebugLog('‚úÖ –ù–∞–π–¥–µ–Ω—ã Next.js pageProps –¥–∞–Ω–Ω—ã–µ', 'success');
                                return parseAPIResponse(pageProps, source);
                            }
                            if (pageProps.initialData) {
                                addDebugLog('‚úÖ –ù–∞–π–¥–µ–Ω—ã Next.js initialData', 'success');
                                return parseAPIResponse(pageProps.initialData, source);
                            }
                        }
                    } catch (e) {
                        // Continue to next strategy
                    }
                }
                
                // Strategy 2: Look for iframe with stock tracker
                const iframe = doc.querySelector('iframe[src*="bot-1"], iframe[src*="stock"], iframe[src*="tracker"]');
                if (iframe && iframe.src) {
                    addDebugLog(`üì¶ –ù–∞–π–¥–µ–Ω iframe: ${iframe.src}`, 'info');
                    // For iframe, we'll need to fetch it with CORS proxy
                    // Return empty for now and log that iframe was detected
                    addDebugLog(`‚ö†Ô∏è HTML –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç iframe - –¥–∞–Ω–Ω—ã–µ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –∏–∑–≤–ª–µ—á–µ–Ω—ã –Ω–∞–ø—Ä—è–º—É—é`, 'warning');
                }
                
                // Strategy 3: Look for stock data in HTML tables or lists
                // Use more specific selectors to avoid duplicates
                const processedItems = new Set(); // Track processed items to avoid duplicates
                
                // Try to find specific stock containers first
                const stockContainers = doc.querySelectorAll(
                    '.stock-item, .gear-item, .seed-item, [data-item], [data-stock-item], ' +
                    'table tr, ul li, .item, .product'
                );
                
                for (const elem of stockContainers) {
                    // Skip if element is too large (likely a container, not an item)
                    const text = elem.textContent.trim();
                    if (text.length > 200) continue;
                    
                    // Skip empty or very short elements
                    if (text.length < 3) continue;
                    
                    // Determine if it's gear or seed
                    const isGear = (
                        elem.classList.contains('gear') || 
                        elem.id.includes('gear') ||
                        elem.dataset.type === 'gear' ||
                        /gear/i.test(text)
                    );
                    
                    const isSeed = (
                        elem.classList.contains('seed') || 
                        elem.id.includes('seed') ||
                        elem.dataset.type === 'seed' ||
                        /seed|plant/i.test(text)
                    );
                    
                    // Skip if not clearly gear or seed
                    if (!isGear && !isSeed) continue;
                    
                    // Extract item name - look for capitalized words
                    const nameMatch = text.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)|([A-Z\s]+)/);
                    if (!nameMatch) continue;
                    
                    const itemName = (nameMatch[1] || nameMatch[2]).trim();
                    
                    // Skip common HTML text that's not item names
                    const skipWords = ['Live', 'Stock', 'Tracker', 'Plants', 'Brainrots', 'Gear', 'Seed', 'Home', 'Features'];
                    if (skipWords.includes(itemName)) continue;
                    
                    // Check if already processed
                    const itemKey = `${isGear ? 'gear' : 'seed'}:${itemName}`;
                    if (processedItems.has(itemKey)) continue;
                    processedItems.add(itemKey);
                    
                    // Extract quantity
                    const qtyMatch = text.match(/[√óx](\d+)|qty[:\s]*(\d+)|amount[:\s]*(\d+)|(\d+)\s*(?:available|in stock)/i);
                    const quantity = qtyMatch ? parseInt(qtyMatch[1] || qtyMatch[2] || qtyMatch[3] || qtyMatch[4] || 1) : 1;
                    
                    const item = {
                        name: itemName,
                        quantity: quantity,
                        price: 0
                    };
                    
                    if (isGear) {
                        gearStock.push(item);
                    } else if (isSeed) {
                        seedStock.push(item);
                    }
                }
                
                // Strategy 4: Look for data attributes
                const dataElements = doc.querySelectorAll('[data-stock], [data-gear], [data-seed], [data-items]');
                for (const elem of dataElements) {
                    try {
                        const dataStock = elem.dataset.stock || elem.dataset.gear || elem.dataset.seed || elem.dataset.items;
                        if (dataStock) {
                            const jsonData = JSON.parse(dataStock);
                            return parseAPIResponse(jsonData, source);
                        }
                    } catch (e) {
                        // Continue
                    }
                }
                
                // Remove duplicates by name
                const uniqueGear = Array.from(new Map(gearStock.map(item => [item.name, item])).values());
                const uniqueSeed = Array.from(new Map(seedStock.map(item => [item.name, item])).values());
                
                addDebugLog(`HTML –ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω: ${uniqueGear.length} gear, ${uniqueSeed.length} seed`, uniqueGear.length + uniqueSeed.length > 0 ? 'success' : 'warning');
                
                return {
                    gear: uniqueGear,
                    seed: uniqueSeed,
                    reportedAt: Date.now(),
                    isValid: uniqueGear.length > 0 || uniqueSeed.length > 0,
                    source: source.id
                };
            } catch (err) {
                addDebugLog(`‚ùå –û—à–∏–±–∫–∞ HTML –ø–∞—Ä—Å–∏–Ω–≥–∞ ${source.name}: ${err.message}`, 'error');
                return {
                    gear: [],
                    seed: [],
                    reportedAt: Date.now(),
                    isValid: false,
                    source: source.id,
                    error: true,
                    message: err.message
                };
            }
        }

        function normalizeItems(items) {
            if (!Array.isArray(items)) return [];
            
            return items.map(item => normalizeItem(item));
        }

        function normalizeItem(item) {
            if (typeof item === 'string') {
                return { name: item, quantity: 1, price: 0 };
            } else if (typeof item === 'object') {
                return {
                    name: item.name || item.item || item.id || 'Unknown',
                    quantity: parseInt(item.currentStock || item.qty || item.quantity || item.amount || item.count || item.stock || 1),
                    price: parseInt(item.currentPrice || item.price || item.cost || 0)
                };
            }
            return { name: 'Unknown', quantity: 1, price: 0 };
        }

        function calculateConsensus() {
            const allSources = Array.from(sourcesData.values());
            const validSources = allSources.filter(data => data.isValid);
            
            addDebugLog(`üìä –ö–æ–Ω—Å–µ–Ω—Å—É—Å: ${validSources.length} –≤–∞–ª–∏–¥–Ω—ã—Ö –∏–∑ ${allSources.length} –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤`, 'info');

            if (validSources.length === 0) {
                addDebugLog('‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å –¥–∞–Ω–Ω—ã–º–∏', 'error');
                return null;
            }

            if (validSources.length === 1) {
                addDebugLog('‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –≤–∞–ª–∏–¥–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫', 'info');
                return validSources[0];
            }
            
            // Check for fresh sources with timestamps divisible by 5 minutes
            function isFreshRoundedTime(timestamp) {
                const date = new Date(timestamp);
                const minutes = date.getMinutes();
                const seconds = date.getSeconds();
                // Check if time is rounded to 5-minute intervals (with max 30 seconds tolerance)
                return minutes % 5 === 0 && seconds <= 30;
            }
            
            // Find sources with fresh rounded timestamps
            const freshSources = validSources.filter(source => isFreshRoundedTime(source.reportedAt));
            
            if (freshSources.length > 0) {
                // Get the most recent fresh source
                const newestFresh = freshSources.sort((a, b) => b.reportedAt - a.reportedAt)[0];
                const newestFreshTime = new Date(newestFresh.reportedAt).toLocaleTimeString('ru-RU');
                
                // Check if this fresh source has different data from other sources
                const otherSources = validSources.filter(s => s.source !== newestFresh.source);
                
                if (otherSources.length > 0) {
                    const otherHash = hashStockData(otherSources[0]);
                    const freshHash = hashStockData(newestFresh);
                    
                    if (otherHash !== freshHash) {
                        // IMPORTANT: Only use fresh source if it has EQUAL OR BETTER data
                        // Don't override sources with more items
                        const freshGearCount = newestFresh.gear.length;
                        const freshSeedCount = newestFresh.seed.length;
                        const freshTotalCount = freshGearCount + freshSeedCount;
                        
                        // Find the best other source (most data)
                        const bestOther = otherSources.reduce((best, current) => {
                            const bestCount = best.gear.length + best.seed.length;
                            const currentCount = current.gear.length + current.seed.length;
                            return currentCount > bestCount ? current : best;
                        }, otherSources[0]);
                        
                        const otherGearCount = bestOther.gear.length;
                        const otherSeedCount = bestOther.seed.length;
                        const otherTotalCount = otherGearCount + otherSeedCount;
                        
                        // Only use fresh source if it has more or equal total items
                        // OR if it has the same total but more gear (gear is more important)
                        if (freshTotalCount > otherTotalCount || 
                            (freshTotalCount === otherTotalCount && freshGearCount >= otherGearCount)) {
                            addDebugLog(`‚≠ê –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º –≤ ${newestFreshTime} (–∫—Ä–∞—Ç–Ω–æ 5 –º–∏–Ω, ${freshGearCount} gear + ${freshSeedCount} seed)`, 'success');
                            return newestFresh;
                        } else {
                            addDebugLog(`‚ö†Ô∏è –°–≤–µ–∂–∏–π –∏—Å—Ç–æ—á–Ω–∏–∫ (${newestFreshTime}) –∏–º–µ–µ—Ç –º–µ–Ω—å—à–µ –¥–∞–Ω–Ω—ã—Ö (${freshGearCount} gear + ${freshSeedCount} seed) —á–µ–º –¥—Ä—É–≥–∏–µ (${otherGearCount} gear + ${otherSeedCount} seed), –ø—Ä–æ–ø—É—Å–∫–∞–µ–º`, 'info');
                        }
                    }
                }
            }
            
            function hashStockData(source) {
                const gearHash = source.gear.map(i => `${i.name}:${i.quantity}`).sort().join(',');
                const seedHash = source.seed.map(i => `${i.name}:${i.quantity}`).sort().join(',');
                return `${gearHash}|${seedHash}`;
            }

            // If no fresh sources with new data, use SMART AGGREGATION
            // Strategy: Get best gear from one source, best seed from another
            // This makes OUR API an aggregator of multiple sources
            
            const sourcesWithGear = validSources.filter(s => s.gear.length > 0);
            const sourcesWithSeed = validSources.filter(s => s.seed.length > 0);
            
            addDebugLog(`üîç –ê–≥—Ä–µ–≥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö: ${sourcesWithGear.length} —Å gear, ${sourcesWithSeed.length} —Å seed`, 'info');
            
            // SMART GEAR CONSENSUS: Use source with most gear items
            let consensusGear = [];
            let gearReportedAt = Date.now();
            let gearSourceId = null;
            
            if (sourcesWithGear.length > 0) {
                // Group gear sources by hash to find consensus
                const gearGroups = new Map();
                sourcesWithGear.forEach(source => {
                    const hash = source.gear.map(i => `${i.name}:${i.quantity}`).sort().join(',');
                    if (!gearGroups.has(hash)) {
                        gearGroups.set(hash, []);
                    }
                    gearGroups.get(hash).push(source);
                });
                
                // Find largest agreement group
                let largestGearGroup = [];
                gearGroups.forEach(group => {
                    if (group.length > largestGearGroup.length) {
                        largestGearGroup = group;
                    }
                });
                
                const bestGearSource = largestGearGroup.sort((a, b) => b.reportedAt - a.reportedAt)[0];
                consensusGear = bestGearSource.gear;
                gearReportedAt = bestGearSource.reportedAt;
                gearSourceId = bestGearSource.source;
                
                const sourceName = SOURCES.find(s => s.id === gearSourceId)?.name || `Source ${gearSourceId}`;
                addDebugLog(`‚öôÔ∏è Gear: ${consensusGear.length} items –æ—Ç ${sourceName}`, 'success');
            } else {
                addDebugLog(`‚ö†Ô∏è –ù–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å gear`, 'info');
            }
            
            // SMART SEED CONSENSUS: Use source with most seed items
            let consensusSeed = [];
            let seedReportedAt = Date.now();
            let seedSourceId = null;
            
            if (sourcesWithSeed.length > 0) {
                // Group seed sources by hash
                const seedGroups = new Map();
                sourcesWithSeed.forEach(source => {
                    const hash = source.seed.map(i => `${i.name}:${i.quantity}`).sort().join(',');
                    if (!seedGroups.has(hash)) {
                        seedGroups.set(hash, []);
                    }
                    seedGroups.get(hash).push(source);
                });
                
                // Find largest agreement group
                let largestSeedGroup = [];
                seedGroups.forEach(group => {
                    if (group.length > largestSeedGroup.length) {
                        largestSeedGroup = group;
                    }
                });
                
                const bestSeedSource = largestSeedGroup.sort((a, b) => b.reportedAt - a.reportedAt)[0];
                consensusSeed = bestSeedSource.seed;
                seedReportedAt = bestSeedSource.reportedAt;
                seedSourceId = bestSeedSource.source;
                
                const sourceName = SOURCES.find(s => s.id === seedSourceId)?.name || `Source ${seedSourceId}`;
                addDebugLog(`üå± Seed: ${consensusSeed.length} items –æ—Ç ${sourceName}`, 'success');
            } else {
                addDebugLog(`‚ö†Ô∏è –ù–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å seed`, 'info');
            }

            // Return aggregated data as OUR source
            return {
                gear: consensusGear,
                seed: consensusSeed,
                reportedAt: Math.max(gearReportedAt, seedReportedAt),
                isValid: consensusGear.length > 0 || consensusSeed.length > 0,
                source: 'aggregated'  // Our aggregated data
            };
        }

        function hashStock(stockData) {
            const gearHash = stockData.gear.map(i => `${i.name}:${i.quantity}`).sort().join(',');
            const seedHash = stockData.seed.map(i => `${i.name}:${i.quantity}`).sort().join(',');
            return `${gearHash}|${seedHash}`;
        }

        function checkForTrackedItems(newStock) {
            const currentHash = hashStock(newStock);
            
            // Skip if stock hasn't changed
            if (currentHash === lastStockHash) return;
            
            lastStockHash = currentHash;

            // Check if any tracked items are in the new stock
            const allItems = [...newStock.gear, ...newStock.seed];
            const itemNames = allItems.map(item => item.name.toLowerCase());

            trackedItems.forEach(trackedItem => {
                if (itemNames.includes(trackedItem.toLowerCase())) {
                    sendNotification(trackedItem);
                }
            });
        }

        function updateStockUI(stock) {
            // Update gear stock
            const gearContainer = document.getElementById('gearStockItems');
            if (stock.gear.length > 0) {
                gearContainer.innerHTML = stock.gear.map(item => createStockItemHTML(item, 'gear')).join('');
            } else {
                gearContainer.innerHTML = '<div class="empty-state">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>';
            }

            // Update seed stock
            const seedContainer = document.getElementById('seedStockItems');
            if (stock.seed.length > 0) {
                seedContainer.innerHTML = stock.seed.map(item => createStockItemHTML(item, 'seed')).join('');
            } else {
                seedContainer.innerHTML = '<div class="empty-state">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>';
            }

            // Update timestamps
            const time = new Date(stock.reportedAt).toLocaleTimeString('ru-RU');
            document.getElementById('gearUpdate').textContent = time;
            document.getElementById('seedUpdate').textContent = time;
            document.getElementById('lastUpdateTime').textContent = `–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: ${time}`;
        }

        function createStockItemHTML(item, type) {
            const isTracked = trackedItems.has(item.name);
            const quantity = parseInt(item.quantity) || 1;
            
            return `
                <div class="stock-item ${isTracked ? 'tracked' : ''}" onclick="toggleTracking('${escapeHtml(item.name)}')">
                    <div class="item-name">${escapeHtml(item.name)}</div>
                    <div class="item-quantity">√ó${quantity}</div>
                </div>
            `;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function addManualTracking() {
            const input = document.getElementById('manualTrackInput');
            const itemName = input.value.trim();
            
            if (itemName) {
                trackedItems.add(itemName);
                localStorage.setItem('trackedItems', JSON.stringify([...trackedItems]));
                addDebugLog(`‚ûï –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ: ${itemName}`, 'success');
                input.value = '';
                updateTrackedItemsUI();
                updateStockUI(currentStock);
            } else {
                addDebugLog('‚ö†Ô∏è –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–µ–¥–º–µ—Ç–∞', 'error');
            }
        }

        function toggleTracking(itemName) {
            if (trackedItems.has(itemName)) {
                trackedItems.delete(itemName);
                addDebugLog(`–û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ: ${itemName}`, 'info');
            } else {
                trackedItems.add(itemName);
                addDebugLog(`–ù–∞—á–∞—Ç–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ: ${itemName}`, 'info');
            }
            
            localStorage.setItem('trackedItems', JSON.stringify([...trackedItems]));
            updateTrackedItemsUI();
            updateStockUI(currentStock);
        }

        function updateTrackedItemsUI() {
            const container = document.getElementById('trackedItems');
            
            if (trackedItems.size === 0) {
                container.innerHTML = '<div class="empty-state">üëÜ –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –≤ —Å—Ç–æ–∫–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤—ã—à–µ</div>';
                return;
            }

            container.innerHTML = [...trackedItems].map(item => `
                <div class="tracked-item">
                    <span>${escapeHtml(item)}</span>
                    <button onclick="toggleTracking('${escapeHtml(item)}')">√ó</button>
                </div>
            `).join('');
        }

        function updateSourcesUI() {
            const container = document.getElementById('sourcesList');
            
            container.innerHTML = SOURCES.map(source => {
                const data = sourcesData.get(source.id);
                let status = 'broken';
                let statusText = '‚ùå –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω';
                let info = '';
                let debugInfo = '';

                if (data && !data.error) {
                    if (data.isValid) {
                        status = 'healthy';
                        statusText = '‚úÖ –†–∞–±–æ—Ç–∞–µ—Ç';
                        info = `‚öôÔ∏è Gear: ${data.gear.length} | üå± Seeds: ${data.seed.length}`;
                        debugInfo = `üîÑ ${new Date(data.reportedAt).toLocaleTimeString('ru-RU')}`;
                    } else {
                        debugInfo = '‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –≤ –æ—Ç–≤–µ—Ç–µ';
                    }
                } else if (data && data.error) {
                    debugInfo = `‚ùå ${data.message || '–û—à–∏–±–∫–∞ —Å–µ—Ç–∏'}`;
                } else {
                    debugInfo = '‚åõ –û–∂–∏–¥–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞...';
                }

                return `
                    <div class="source-item ${status}">
                        <div class="source-header">
                            <span class="source-name">${source.name} (${source.type})</span>
                            <span class="source-status ${status}">${statusText}</span>
                        </div>
                        <div class="source-info">${info || '‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è'}</div>
                        <div class="debug-info">${debugInfo}</div>
                    </div>
                `;
            }).join('');
        }

        function updateStatusBar() {
            const healthySources = Array.from(sourcesData.values()).filter(data => data.isValid).length;
            document.getElementById('healthySources').textContent = `–ò—Å—Ç–æ—á–Ω–∏–∫–æ–≤: ${healthySources}/4`;
            
            if (healthySources > 0) {
                document.getElementById('statusText').textContent = '‚úÖ –ê–∫—Ç–∏–≤–µ–Ω';
                document.getElementById('statusIndicator').classList.add('active');
            } else {
                document.getElementById('statusText').textContent = '‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
                document.getElementById('statusIndicator').classList.remove('active');
            }
        }

        // Update local API with consensus data
        async function updateLocalAPI(stockData) {
            try {
                // Format data for our API: only name and quantity (no price, category, etc)
                const simplifiedGear = stockData.gear.map(item => ({
                    name: item.name,
                    quantity: item.quantity
                }));
                
                const simplifiedSeed = stockData.seed.map(item => ({
                    name: item.name,
                    quantity: item.quantity
                }));
                
                const response = await fetch('/api/stock', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        gear: simplifiedGear,
                        seed: simplifiedSeed,
                        reportedAt: stockData.reportedAt
                    })
                });
                
                if (response.ok) {
                    addDebugLog('üì° API –æ–±–Ω–æ–≤–ª–µ–Ω: /api/stock', 'success');
                } else {
                    addDebugLog('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å API', 'warning');
                }
            } catch (error) {
                // Silently fail if API is not available
                console.log('API update skipped:', error.message);
            }
        }
    </script>
</body>
</html>
